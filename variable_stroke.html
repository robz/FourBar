<html>
<style>
body {
    text-align: center;
}

.configinput {
    width: 30px;
}

canvas {
    margin: 1px 0px 0px 0px;
    padding: 0px 0px 0px 0px;
}
</style>
<h3>Variable-stroke mechanism</h3>
adjust link lengths and positions using scrollbars below<br/>
<div id="container"></div>
<div id="pivotLength_input"></div>
<div id="pivotAngle_input"></div>
<div id="pivotX_input"></div>
<div id="pivotY_input"></div>
<div id="angleMag"></div>
<div id="angleCenter"></div>
<script src="../plotjs/plot.js"></script>
<script src="fourbar.js"></script>
<script src="scrollbar.js"></script>
<script>
(function () {
    "use strict";
    
    var scale = 7.0,
        scaleY = 3/4,
    
        plot = new Plot({
            container: "container",
            pixelWidth: 500,
            pixelHeight: 300,
            minX: -4*scale,
            maxX: 16*scale,
            minY: -10*scale*scaleY,
            maxY: 8*scale*scaleY,
            pointRadius: 0.2*scale,
            lineWidth: 0.1*scale,
            drawColor: "blue",
            backgroundColor: "lightGray"
            }),

        scalingFactor = 6.4,

        pivotPoint = {
            x: -0.324864*scalingFactor, 
            y: -4.343029*scalingFactor
            },
        pivotAngle = Math.PI/2,
        pivotLength = 5.601562*scalingFactor,

        fb1 = new FourBar({
            a: 7.35, 
            b: 21.53, 
            c: -27.4, 
            O2: {x: -2.171875*scalingFactor, 
                 y: -0.956250*scalingFactor},
            O4: {x: pivotPoint.x + pivotLength*Math.cos(pivotAngle), 
                 y: pivotPoint.y + pivotLength*Math.sin(pivotAngle)},
            useSafeMath: true
            }),

        fb2 = new FourBar({
            a: 27.4,
            b: 49.344, 
            c: -31.88,
            O2: fb1.O4,
            O4: {x: 8.921875*scalingFactor, 
                 y: 0.328125*scalingFactor},
            theta2: Math.PI*2 - 2*Math.PI/3,
            useSafeMath: true
            }),

        DT = 30;


    // 
    // Calculations
    //
    
    var euclid = function (p1, p2) {
        var dx = p1.x - p2.x,
            dy = p1.y - p2.y;
        return Math.sqrt(dx * dx + dy * dy);
    };
    
    var calcLawOfCosines = function (p1, p2, p3) {
        var a = euclid(p1, p3),
            b = euclid(p1, p2),
            c = euclid(p2, p3);
            
        return Math.acos((b*b + c*c - a*a)/(2*b*c));
    };

    var calcLineFunction = function (p1, p2) {
        var m = (p2.y - p1.y)/(p2.x - p1.x),
            b = p1.y - p1.x * m;

        return function (x) {
            return m*x + b;
        };
    };
    
    var doMath = function () {
        fb1.runPositionAnalysis();
        fb1.recalculatePoints();
        
        var fb2input = calcLawOfCosines(fb1.pB, fb2.O2, fb2.O4);
        if (calcLineFunction(fb2.O2, fb2.O4)(fb1.pB.x) > fb1.pB.y) {
            fb2input = Math.PI*2 - fb2input;
        }
        fb2.theta2 = fb2input;
        
        fb2.a = -fb1.c;
        
        fb2.runPositionAnalysis();
        fb2.recalculatePoints();
    };
    
    var calcPath = function (numPoints) {
        var points = [],
            angles = [];
        
        fb1.pushState();
        fb2.pushState();
        
        try {
            for (var i = 0; i < numPoints; i++) {
                fb1.theta2 = i * Math.PI * 2 / numPoints;
                doMath();
                points.push([fb2.pB.x, fb2.pB.y]);
                angles.push(Math.atan2(
                    fb2.pB.y - fb2.O4.y, 
                    fb2.pB.x - fb2.O4.x));
            }
        } catch (e) {
            return false;
        } finally {
            fb1.popState();
            fb2.popState();
        }
        
        setAngles(angles);
        
        calcPath.latest = points;
        
        return true;
    };
    
    var setAngles = function (angles) {
        var minAngle = angles[0], 
            maxAngle = angles[0];
        
        angles.forEach(function (elem, index, array) {
            if (elem < minAngle) {
                minAngle = elem;
            }
            if (elem > maxAngle) {
                maxAngle = elem;
            }
        });

        document.getElementById("angleMag").innerHTML = "magitude of output angle: " + (maxAngle - minAngle);
        document.getElementById("angleCenter").innerHTML = "center angle of output oscilation: " + ((minAngle + maxAngle)/2);
    };

    
    //
    // Input scroll bars
    //
    
    var bars = [];
    
    var barData = [
        {name:"pivotAngle_input", min: 0, max: Math.PI*2, startX: pivotAngle,
        movedToCallback: function (x) {
            var tmpAngle = pivotAngle,
                tmpX = fb1.O4.x,
                tmpY = fb1.O4.y;
            
            pivotAngle = x;
            fb1.O4.x = pivotPoint.x + pivotLength*Math.cos(pivotAngle);
            fb1.O4.y = pivotPoint.y + pivotLength*Math.sin(pivotAngle);
            
            if (!calcPath(100)) {
                pivotAngle = tmpAngle;
                fb1.O4.x = tmpX;
                fb1.O4.y = tmpY;
                bars[0].bar.setPosition(tmpAngle);
            }
        }},

        {name:"pivotLength_input", min: 0, max: 100, startX: pivotLength,
        movedToCallback: function (x) {
            var tmpLen = pivotLength,
                tmpX = fb1.O4.x,
                tmpY = fb1.O4.y;
            
            pivotLength = x;
            fb1.O4.x = pivotPoint.x + pivotLength*Math.cos(pivotAngle);
            fb1.O4.y = pivotPoint.y + pivotLength*Math.sin(pivotAngle);
            
            if (!calcPath(100)) {
                pivotLength = tmpLen;
                fb1.O4.x = tmpX;
                fb1.O4.y = tmpY;
                bars[1].bar.setPosition(pivotLength);
            }
        }},

        {name:"pivotX_input", min: -50, max: 50, startX: pivotPoint.x,
        movedToCallback: function (x) {
            var tmpLen = pivotPoint.x,
                tmpX = fb1.O4.x,
                tmpY = fb1.O4.y;
            
            pivotPoint.x = x;
            fb1.O4.x = pivotPoint.x + pivotLength*Math.cos(pivotAngle);
            fb1.O4.y = pivotPoint.y + pivotLength*Math.sin(pivotAngle);
            
            if (!calcPath(100)) {
                pivotPoint.x = tmpLen;
                fb1.O4.x = tmpX;
                fb1.O4.y = tmpY;
                bars[2].bar.setPosition(pivotPoint.x);
            }
        }},

        {name:"pivotY_input", min: -50, max: 50, startX: pivotPoint.y,
        movedToCallback: function (x) {
            var tmpLen = pivotPoint.y,
                tmpX = fb1.O4.x,
                tmpY = fb1.O4.y;
            
            pivotPoint.y = x;
            fb1.O4.x = pivotPoint.x + pivotLength*Math.cos(pivotAngle);
            fb1.O4.y = pivotPoint.y + pivotLength*Math.sin(pivotAngle);
            
            if (!calcPath(100)) {
                pivotPoint.y = tmpLen;
                fb1.O4.x = tmpX;
                fb1.O4.y = tmpY;
                bars[3].bar.setPosition(pivotPoint.y);
            }
        }},
    ];
    
    barData.forEach(function (elem, index) {
        bars[index] = {
            field: elem.field,
            bar: new ScrollBar({
                container: elem.name,
                label: elem.name,
                pixelWidth: 500,
                pixelHeight: 30,
                minX: elem.min,
                maxX: elem.max,
                startX: elem.startX,
                drawColor: "darkGray",
                backgroundColor: "lightGray",
                movedToCallback: elem.movedToCallback
            })
        };
    });
    
    
    // 
    // Graphics
    //
    
    var drawLinkages = function (fb) {
        plot.drawPoint(fb1.O2.x, fb1.O2.y);
        plot.drawPoint(fb1.O4.x, fb1.O4.y);
        plot.drawPoint(fb1.pA.x, fb1.pA.y);
        plot.drawPoint(fb1.pB.x, fb1.pB.y);
        plot.drawLine(fb1.O2.x, fb1.O2.y, fb1.pA.x, fb1.pA.y);
        plot.drawLine(fb1.pA.x, fb1.pA.y, fb1.pB.x, fb1.pB.y);
        plot.drawLine(fb1.pB.x, fb1.pB.y, fb1.O4.x, fb1.O4.y);
        
        plot.drawPoint(fb2.O2.x, fb2.O2.y);
        plot.drawPoint(fb2.O4.x, fb2.O4.y);
        plot.drawPoint(fb2.pB.x, fb2.pB.y);
        plot.drawLine(fb2.O2.x, fb2.O2.y, fb2.pA.x, fb2.pA.y);
        plot.drawLine(fb2.pA.x, fb2.pA.y, fb2.pB.x, fb2.pB.y);
        plot.drawLine(fb2.pB.x, fb2.pB.y, fb2.O4.x, fb2.O4.y);
        
        plot.drawPoint(pivotPoint.x, pivotPoint.y);
        plot.drawLine(pivotPoint.x, pivotPoint.y, fb1.O4.x, fb1.O4.y);
    };
    
    var iteration = (function () {
        var count = 0,
            maxCount = 200,
            speed = 2;
    
        return function () {
            fb1.theta2 = count * Math.PI * 2 / maxCount;
            
            doMath();
            
            plot.restoreToBackground();
            drawLinkages();
            
            if (!calcPath.latest) {
                calcPath(100);
            }
            
            plot.drawPath(calcPath.latest, {drawColor:"red"});
            
            count = (count + speed)%maxCount;
        }
    })();

    setInterval(iteration, DT);
}());
</script>
</html>