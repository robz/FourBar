<html>
<style>
body {
    text-align: center;
}

.configinput {
    width: 30px;
}

canvas {
    margin: 1px 0px 0px 0px;
    padding: 0px 0px 0px 0px;
}
</style>
<h3>Variable-stroke mechanism</h3>
adjust link lengths using scrollbars below<br/>
<div id="container"></div>
<div id="a_input"></div>
<div id="b_input"></div>
<div id="c_input"></div>
<div id="O4_input"></div>
<script src="../plotjs/plot.js"></script>
<script src="fourbar.js"></script>
<script src="scrollbar.js"></script>
<script>
(function () {
    "use strict";
    
    var scale = 6.0,
    
        plot = new Plot({
            container: "container",
            pixelWidth: 500,
            pixelHeight: 400,
            minX: -2*scale,
            maxX: 18*scale,
            minY: -10*scale,
            maxY: 8*scale,
            pointRadius: 0.2*scale,
            lineWidth: 0.1*scale,
            drawColor: "blue",
            backgroundColor: "lightGray"
            }),
            
        pivotPoint = {x: 30, y: 0},
        pivotAngle = Math.PI/2*3,
        pivotLength = 13.8,
        
        fb1 = new FourBar({
            a: 7.35, 
            b: 21.53, 
            c: -27.4, 
            O2: {x: 0, y: 0},
            O4: {x: pivotPoint.x + pivotLength*Math.cos(pivotAngle), 
                 y: pivotPoint.y + pivotLength*Math.sin(pivotAngle)},
            useSafeMath: true
            }),
        
        fb2 = new FourBar({
            a: 27.4,
            b: 75, 
            c: -31.88,
            O2: fb1.O4,
            O4: {x: fb1.O4.x + 50, y: 0},
            theta2: Math.PI*2 - 2*Math.PI/3,
            useSafeMath: true
            }),
        
        DT = 30;

    var euclid = function (p1, p2) {
        var dx = p1.x - p2.x,
            dy = p1.y - p2.y;
        return Math.sqrt(dx * dx + dy * dy);
    };
    //
    // Input scroll bars
    //
    /*
    
    var bars = [];
    
    [{name:"fb1_a_input", field: "a", min: 0, max: 50},
     {name:"fb1_b_input", field: "b", min: 0, max: 50}, 
     {name:"fb1_c_input", field: "c", min: 0, max: 50},
     {name:"fb1_O4_input", field: "O4", min: 0, max: 50, 
        startX: euclid(fb.O2, fb.O4),
        movedToCallback: function (v, bar) {
            var zeta = Math.atan2(fb.O4.y - fb.O2.y, fb.O4.x - fb.O2.x),
                tmp = fb.O4,
                tmpd = euclid(fb.O2, fb.O4);

            fb.O4 = {
                x: fb.O2.x + v * Math.cos(zeta),
                y: fb.O2.y + v * Math.sin(zeta)
                };

            if (!calcPath(100)) {
                fb.O4 = tmp;
                bar.setPosition(tmpd);
            }
        }}
    ].forEach(function (elem, index) {
        bars[index] = {
            field: elem.field,
            bar: new ScrollBar({
                container: elem.name,
                pixelWidth: 500,
                pixelHeight: 50,
                minX: elem.min,
                maxX: elem.max,
                startX: elem.startX || Math.abs(fb[elem.field]),
                drawColor: "darkGray",
                backgroundColor: "lightGray",
                movedToCallback: function (x) {
                    if (elem.movedToCallback) {
                        elem.movedToCallback(x, bars[index].bar);
                        return;
                    }
                
                    var tmp = fb[elem.field];
                    fb[elem.field] = x * ((tmp<0)?-1:1);
                    
                    if (!calcPath(100)) {
                        fb[elem.field] = tmp;
                        bars[index].bar.setPosition(Math.abs(tmp));
                    }
                }, 
            })
        };
    });
    */
    
    // 
    // Calculations...
    //
    
    var calcPath = function (fb, numPoints) {
        var points = [];
        
        fb.pushState();
        
        try {
            for (var i = 0; i < numPoints; i++) {
                fb.theta2 = i * Math.PI * 2 / numPoints;
                fb.runPositionAnalysis();
                fb.recalculatePoints();
                points.push([fb.pB.x, fb.pB.y]);
            }
            
        } catch (e) {
            return false;
        } finally {
            fb.popState();
        }

        calcPath.latest = points;
        
        return true;
    };
    
    
    // 
    // Graphics
    //
    
    var drawLinkages = function (fb) {
        plot.drawPoint(fb1.O2.x, fb1.O2.y);
        plot.drawPoint(fb1.O4.x, fb1.O4.y);
        plot.drawPoint(fb1.pA.x, fb1.pA.y);
        plot.drawPoint(fb1.pB.x, fb1.pB.y);
        plot.drawLine(fb1.O2.x, fb1.O2.y, fb1.pA.x, fb1.pA.y);
        plot.drawLine(fb1.pA.x, fb1.pA.y, fb1.pB.x, fb1.pB.y);
        plot.drawLine(fb1.pB.x, fb1.pB.y, fb1.O4.x, fb1.O4.y);
        
        plot.drawPoint(fb2.O2.x, fb2.O2.y);
        plot.drawPoint(fb2.O4.x, fb2.O4.y);
        plot.drawPoint(fb2.pB.x, fb2.pB.y);
        plot.drawLine(fb2.O2.x, fb2.O2.y, fb2.pA.x, fb2.pA.y);
        plot.drawLine(fb2.pA.x, fb2.pA.y, fb2.pB.x, fb2.pB.y);
        plot.drawLine(fb2.pB.x, fb2.pB.y, fb2.O4.x, fb2.O4.y);
        
        plot.drawPoint(pivotPoint.x, pivotPoint.y);
        plot.drawLine(pivotPoint.x, pivotPoint.y, fb1.O4.x, fb1.O4.y);
    };
    
    var calcLawOfCosines = function (p1, p2, p3) {
        var a = euclid(p1, p3),
            b = euclid(p1, p2),
            c = euclid(p2, p3);
            
        return Math.acos((b*b + c*c - a*a)/(2*b*c));
    };

    var calcLineFunction = function (p1, p2) {
        var m = (p2.y - p1.y)/(p2.x - p1.x),
            b = p1.y - p1.x * m;

        return function (x) {
            return m*x + b;
        };
    };
    
    var iteration = (function () {
        var count = 0,
            maxCount = 200,
            speed = 2;
    
        return function () {
            fb1.theta2 = count * Math.PI * 2 / maxCount;
            
            fb1.runPositionAnalysis();
            fb1.recalculatePoints();
            
            var fb2input = calcLawOfCosines(fb1.pB, fb2.O2, fb2.O4);
            if (calcLineFunction(fb2.O2, fb2.O4)(fb1.pB.x) > fb1.pB.y) {
                fb2input = Math.PI*2 - fb2input;
            }
            
            fb2.theta2 = fb2input;
            
            fb2.runPositionAnalysis();
            fb2.recalculatePoints();
            
            plot.restoreToBackground();
            drawLinkages();
            
            count = (count + speed)%maxCount;
        }
    })();

    setInterval(iteration, DT);
}());
</script>
</html>